#!/usr/bin/env bash
set -euo pipefail

# Debian 12 ä¸€é”®ç”Ÿæˆè„šæœ¬ï¼ˆç¨³å®šå¢å¼ºç‰ˆï¼šçœCPU + ç¨³å®šä¼˜å…ˆï¼‰
# å·²åŒ…å«ä¿®å¤/å¢å¼ºï¼š
# 1) need_basic_tools: apt-get update ä¸åé”™
# 2) Xray outbounds é»˜è®¤å‡ºå£é¡ºåºï¼šdirect ç¬¬ä¸€ï¼Œapi æœ€åï¼ˆé¿å…é»˜è®¤å‡ºå£è·‘åï¼‰
# 3) pq_add/pq_del ç«¯å£æ ¡éªŒ
# 4) systemd-run TTL å¤±è´¥ä¸å†é™é»˜åæ‰ + æ£€æŸ¥/æç¤º vless-gc.timerï¼ˆå¿…è¦æ—¶å°è¯•å¯ç”¨ï¼‰
# 5) /tmp ä¸´æ—¶æ–‡ä»¶ mktemp æƒé™ä¸æ¸…ç†
# 6) pq_audit.shï¼šcounter ç¼ºå¤±ä¸å†è§¦å‘ set -e é€€å‡º
# 7) é…ç½®ç»Ÿä¸€åŒ–ï¼šå†™å…¥ /usr/local/etc/xray/env.confï¼Œå­è„šæœ¬ç»Ÿä¸€è¯»å–ï¼ˆAPI_PORT ä¸å†ç¡¬ç¼–ç æ¼‚ç§»ï¼‰
# 8) ç«¯å£åˆ†é…ï¼šæœ€å°ä½¿ç”¨æ•° + éšæœºæ‰“æ•£ï¼ˆé¿å…çƒ­ç‚¹åå‘ç¬¬ä¸€ä¸ªç«¯å£ï¼‰
# 9) âœ… ä¿®å¤â€œé”é‡å…¥â€é—®é¢˜ï¼švless_rmu_one.sh å¯å¤ç”¨çˆ¶è¿›ç¨‹ fd=9 é”ï¼ŒGC/clear_all ä¸å†å‡åˆ é™¤

REPO_BASE="https://raw.githubusercontent.com/liucong552-art/debian12-/main"
UP_BASE="/usr/local/src/debian12-upstream"

TEMP_PORT_START=40000
TEMP_PORT_COUNT=40  # 40000-40039

check_debian12() {
  if [[ "$(id -u)" -ne 0 ]]; then
    echo "âŒ è¯·ä»¥ root è¿è¡Œæœ¬è„šæœ¬"
    exit 1
  fi
  local codename
  codename=$(grep -E "^VERSION_CODENAME=" /etc/os-release 2>/dev/null | cut -d= -f2 || true)
  if [[ "$codename" != "bookworm" ]]; then
    echo "âŒ ä»…é€‚ç”¨äº Debian 12 (bookworm)ï¼Œå½“å‰: ${codename:-æœªçŸ¥}"
    exit 1
  fi
}

need_basic_tools() {
  export DEBIAN_FRONTEND=noninteractive
  # âœ… ä¿®å¤ï¼šupdate å¤±è´¥å°±é€€å‡ºï¼Œä¸å†åé”™ç»§ç»­è·‘
  apt-get update -y || apt-get update -y || { echo "âŒ apt-get update å¤±è´¥"; exit 1; }

  apt-get install -y \
    curl wget openssl python3 nftables coreutils logrotate ca-certificates iproute2 util-linux \
    || { echo "âŒ apt ä¾èµ–å®‰è£…å¤±è´¥"; exit 1; }
}

download_upstreams() {
  echo "â¬‡ ä¸‹è½½/æ›´æ–° ä¸Šæ¸¸æ–‡ä»¶åˆ° ${UP_BASE} ..."
  mkdir -p "$UP_BASE"
  curl -fsSL --connect-timeout 3 --max-time 25 --retry 3 --retry-delay 1 --retry-all-errors \
    "${REPO_BASE}/xray-install-release.sh" -o "${UP_BASE}/xray-install-release.sh"
  chmod +x "${UP_BASE}/xray-install-release.sh"
}

install_logrotate_rules() {
  echo "ğŸ§© é…ç½®æ—¥å¿—è½®è½¬ï¼ˆä¿ç•™ 2 å¤©ï¼Œæ—§çš„è‡ªåŠ¨åˆ ï¼‰..."
  cat >/etc/logrotate.d/portquota-vless <<'LR'
/var/log/pq-save.log
/var/log/vless-user.log
/var/log/vless-user-gc.log
/var/log/vless-user-restore.log
{
  daily
  rotate 2
  missingok
  notifempty
  nocompress
  copytruncate
  dateext
  maxage 2
}
LR
}

install_update_all() {
  cat >/usr/local/bin/update-all << 'EOF'
#!/bin/bash
set -euo pipefail

[ "$(id -u)" -eq 0 ] || { echo "âŒ root è¿è¡Œ"; exit 1; }
codename=$(grep -E "^VERSION_CODENAME=" /etc/os-release 2>/dev/null | cut -d= -f2 || true)
[ "$codename" = "bookworm" ] || { echo "âŒ ä»… Debian12 bookworm"; exit 1; }

export DEBIAN_FRONTEND=noninteractive

echo "ğŸš€ æ›´æ–°ç³»ç»ŸåŒ…ï¼ˆä¸é»˜è®¤æ›´æ¢å†…æ ¸ï¼‰..."
apt-get update -y
apt-get full-upgrade -y
apt-get --purge autoremove -y
apt-get autoclean -y
apt-get clean -y
echo "âœ… è½¯ä»¶åŒ…æ›´æ–°å®Œæˆ"

KVER="$(uname -r | sed 's/-.*//')"
if [ "$(printf '%s\n' "4.9" "$KVER" | sort -V | head -n1)" = "$KVER" ] && [ "$KVER" != "4.9" ]; then
  echo "âš ï¸ æ£€æµ‹åˆ°å†…æ ¸ç‰ˆæœ¬ $KVER < 4.9ï¼ŒBBR å¯èƒ½ä¸å¯ç”¨ã€‚"
  echo "å¦‚éœ€å®‰è£… backports å†…æ ¸ï¼Œè¯·æ‰‹åŠ¨æ‰§è¡Œï¼š"
  echo "  echo 'deb http://deb.debian.org/debian bookworm-backports main contrib non-free non-free-firmware' > /etc/apt/sources.list.d/backports.list"
  echo "  apt-get update -y"
  echo "  apt-get -t bookworm-backports install -y linux-image-amd64 linux-headers-amd64"
  echo "  reboot"
else
  echo "âœ… å½“å‰å†…æ ¸ $KVER å·²æ»¡è¶³ BBR è¦æ±‚ï¼Œæ— éœ€æ›´æ¢å†…æ ¸"
fi
EOF
  chmod +x /usr/local/bin/update-all
}

install_vless_script_singleproc_40ports() {
  echo "ğŸ§© å†™å…¥ /root/onekey_reality_ipv4.shï¼ˆå« env.conf + outbounds é¡ºåºä¿®å¤ï¼‰..."

  cat >/root/onekey_reality_ipv4.sh <<'EOF'
#!/usr/bin/env bash
set -euo pipefail
EOF

  cat >>/root/onekey_reality_ipv4.sh <<EOF
REPO_BASE="${REPO_BASE}"
UP_BASE="${UP_BASE}"
TEMP_PORT_START=${TEMP_PORT_START}
TEMP_PORT_COUNT=${TEMP_PORT_COUNT}
EOF

  cat >>/root/onekey_reality_ipv4.sh <<'EOF'

check_debian12() {
  [ "$(id -u)" -eq 0 ] || { echo "âŒ root"; exit 1; }
  local codename
  codename=$(grep -E "^VERSION_CODENAME=" /etc/os-release 2>/dev/null | cut -d= -f2 || true)
  [ "$codename" = "bookworm" ] || { echo "âŒ Debian12 bookworm only"; exit 1; }
}

install_xray() {
  mkdir -p "$UP_BASE"
  local inst="$UP_BASE/xray-install-release.sh"
  if [ ! -x "$inst" ]; then
    curl -fsSL --connect-timeout 3 --max-time 30 --retry 3 --retry-delay 1 --retry-all-errors \
      "$REPO_BASE/xray-install-release.sh" -o "$inst"
    chmod +x "$inst"
  fi
  "$inst" install --without-geodata
  [ -x /usr/local/bin/xray ] || { echo "âŒ xray æœªå®‰è£…æˆåŠŸ"; exit 1; }
}

is_private_ip() {
  local ip="$1"
  [[ "$ip" =~ ^10\. ]] && return 0
  [[ "$ip" =~ ^192\.168\. ]] && return 0
  [[ "$ip" =~ ^172\.(1[6-9]|2[0-9]|3[0-1])\. ]] && return 0
  return 1
}

detect_ipv4_public_first() {
  local ip=""
  ip="$(curl -4fsS --connect-timeout 2 --max-time 6 --retry 2 --retry-delay 1 --retry-all-errors https://api.ipify.org || true)"
  if [[ -n "$ip" && ! is_private_ip "$ip" ]]; then
    echo "$ip"; return 0
  fi
  ip="$(ip -4 route get 1.1.1.1 2>/dev/null | awk '{for(i=1;i<=NF;i++) if($i=="src"){print $(i+1); exit}}' || true)"
  if [[ -n "$ip" && ! is_private_ip "$ip" ]]; then
    echo "$ip"; return 0
  fi
  ip="$(hostname -I 2>/dev/null | awk '{print $1}' || true)"
  if [[ -n "$ip" && ! is_private_ip "$ip" ]]; then
    echo "$ip"; return 0
  fi
  echo ""
}

check_port_free_443() {
  if ss -lntH 2>/dev/null | awk '{print $4}' | grep -Eq '(:|\])443$'; then
    echo "âŒ 443 å·²è¢«å ç”¨ï¼Œxray æ— æ³•ç›‘å¬ã€‚è¯·å…ˆé‡Šæ”¾ 443 æˆ–æ”¹ MAIN_PORTã€‚"
    ss -lntp 2>/dev/null | grep -E '(:|\])443\b' || true
    exit 1
  fi
}

check_debian12

# â€”â€” æ ¸å¿ƒé…ç½®ï¼ˆä¼šå†™å…¥ env.conf ä¾›å…¶å®ƒè„šæœ¬å¤ç”¨ï¼‰â€”â€”
REALITY_DOMAIN="www.apple.com"
MAIN_PORT=443
MAIN_TAG="vless-main"

API_HOST="127.0.0.1"
API_PORT=10085
API_TAG="api"

SERVER_IP="$(detect_ipv4_public_first)"
[ -n "$SERVER_IP" ] || { echo "âŒ æ— æ³•æ£€æµ‹å…¬ç½‘ IPv4ï¼ˆæˆ–æ‹¿åˆ°çš„æ˜¯å†…ç½‘ IPï¼‰"; exit 1; }

check_port_free_443

echo "=== 1) åªå¼€å¯ fq + bbrï¼ˆå…¶ä½™ sysctl ä¿æŒé»˜è®¤ï¼‰==="
cat >/etc/sysctl.d/99-bbr.conf <<'SYS'
net.core.default_qdisc=fq
net.ipv4.tcp_congestion_control=bbr
SYS
modprobe tcp_bbr 2>/dev/null || true
sysctl -p /etc/sysctl.d/99-bbr.conf >/dev/null 2>&1 || true
echo "å½“å‰: qdisc=$(sysctl -n net.core.default_qdisc 2>/dev/null || echo unknown), cc=$(sysctl -n net.ipv4.tcp_congestion_control 2>/dev/null || echo unknown)"

echo "=== 2) å®‰è£…/æ›´æ–° xray ==="
install_xray
systemctl stop xray 2>/dev/null || true

echo "=== 3) UUID + Reality å¯†é’¥ ==="
UUID="$(/usr/local/bin/xray uuid)"

KEY_OUT="$(/usr/local/bin/xray x25519)"
PRIVATE_KEY="$(printf '%s\n' "$KEY_OUT" | awk '/^PrivateKey:/ {print $2;exit} /^Private key:/ {print $3;exit}')"
PUBLIC_KEY="$(printf '%s\n' "$KEY_OUT" | awk '/^PublicKey:/ {print $2;exit} /^Public key:/ {print $3;exit} /^Password:/ {print $2;exit}')"
[ -n "$PRIVATE_KEY" ] && [ -n "$PUBLIC_KEY" ] || { echo "âŒ Reality key è§£æå¤±è´¥"; echo "$KEY_OUT"; exit 1; }

SHORT_ID="$(openssl rand -hex 8)"

CFG_DIR=/usr/local/etc/xray
mkdir -p "$CFG_DIR"

# âœ… ç»Ÿä¸€é…ç½®æ–‡ä»¶ï¼šå­è„šæœ¬ç»Ÿä¸€è¯»å–ï¼Œé¿å… API_PORT/ç«¯å£æ®µç¡¬ç¼–ç æ¼‚ç§»
ENV_CONF="${CFG_DIR}/env.conf"
cat >"$ENV_CONF" <<CONFENV
REALITY_DOMAIN=${REALITY_DOMAIN}
MAIN_PORT=${MAIN_PORT}
API_HOST=${API_HOST}
API_PORT=${API_PORT}
TEMP_PORT_START=${TEMP_PORT_START}
TEMP_PORT_COUNT=${TEMP_PORT_COUNT}
CONFENV
chmod 600 "$ENV_CONF" 2>/dev/null || true

TMP_INBOUNDS=""
for i in $(seq 0 $((TEMP_PORT_COUNT-1))); do
  p=$((TEMP_PORT_START+i))
  tag="vless-tmp-$p"
  TMP_INBOUNDS+=$(cat <<JSON
    ,
    {
      "tag": "${tag}",
      "listen": "0.0.0.0",
      "port": ${p},
      "protocol": "vless",
      "settings": {
        "clients": [],
        "decryption": "none"
      },
      "streamSettings": {
        "network": "tcp",
        "security": "reality",
        "realitySettings": {
          "show": false,
          "dest": "${REALITY_DOMAIN}:443",
          "xver": 0,
          "serverNames": [ "${REALITY_DOMAIN}" ],
          "privateKey": "${PRIVATE_KEY}",
          "shortIds": [ "${SHORT_ID}" ]
        }
      }
    }
JSON
)
done

cat >"$CFG_DIR/config.json" <<CONF
{
  "api": { "tag": "${API_TAG}", "services": ["HandlerService"] },
  "log": { "loglevel": "warning" },
  "inbounds": [
    {
      "tag": "${MAIN_TAG}",
      "listen": "0.0.0.0",
      "port": ${MAIN_PORT},
      "protocol": "vless",
      "settings": {
        "clients": [
          { "id": "${UUID}", "email": "main@local", "flow": "xtls-rprx-vision" }
        ],
        "decryption": "none"
      },
      "streamSettings": {
        "network": "tcp",
        "security": "reality",
        "realitySettings": {
          "show": false,
          "dest": "${REALITY_DOMAIN}:443",
          "xver": 0,
          "serverNames": [ "${REALITY_DOMAIN}" ],
          "privateKey": "${PRIVATE_KEY}",
          "shortIds": [ "${SHORT_ID}" ]
        }
      }
    }${TMP_INBOUNDS}
    ,
    {
      "tag": "${API_TAG}",
      "listen": "${API_HOST}",
      "port": ${API_PORT},
      "protocol": "dokodemo-door",
      "settings": { "address": "${API_HOST}" }
    }
  ],
  "routing": {
    "rules": [
      { "type": "field", "inboundTag": ["${API_TAG}"], "outboundTag": "${API_TAG}" }
    ]
  },
  "outbounds": [
    { "tag": "direct", "protocol": "freedom" },
    { "tag": "block",  "protocol": "blackhole" },
    { "tag": "${API_TAG}", "protocol": "api" }
  ]
}
CONF

mkdir -p /etc/systemd/system/xray.service.d
cat >/etc/systemd/system/xray.service.d/override.conf <<'OVR'
[Service]
LimitNOFILE=1048576
Nice=-5
Restart=on-failure
RestartSec=1
OVR

/usr/local/bin/xray run -test -config /usr/local/etc/xray/config.json

systemctl daemon-reload
systemctl enable xray >/dev/null 2>&1 || true
systemctl restart xray

sleep 1
if ! systemctl is-active --quiet xray.service; then
  echo "âŒ xray.service å¯åŠ¨å¤±è´¥ï¼š"
  systemctl status xray.service --no-pager || true
  journalctl -u xray.service -n 80 --no-pager || true
  exit 1
fi

NODE_NAME="VLESS-REALITY-IPv4-APPLE"
VLESS_URL="vless://${UUID}@${SERVER_IP}:${MAIN_PORT}?type=tcp&security=reality&encryption=none&flow=xtls-rprx-vision&sni=${REALITY_DOMAIN}&fp=chrome&pbk=${PUBLIC_KEY}&sid=${SHORT_ID}#${NODE_NAME}"

echo "$VLESS_URL" >/root/vless_reality_vision_url.txt
if base64 --help 2>/dev/null | grep -q -- "-w"; then
  echo "$VLESS_URL" | base64 -w0 >/root/v2ray_subscription_base64.txt
else
  echo "$VLESS_URL" | base64 | tr -d '\n' >/root/v2ray_subscription_base64.txt
fi

echo "âœ… ä¸»èŠ‚ç‚¹å®Œæˆï¼š443 + å•è¿›ç¨‹ + ${TEMP_PORT_COUNT} ä¸´æ—¶ç«¯å£(${TEMP_PORT_START}-$((TEMP_PORT_START+TEMP_PORT_COUNT-1))) + API(${API_HOST}:${API_PORT})"
echo "ç»Ÿä¸€é…ç½®æ–‡ä»¶ï¼š${ENV_CONF}"
echo "ä¸»èŠ‚ç‚¹é“¾æ¥ï¼š"
cat /root/vless_reality_vision_url.txt
EOF

  chmod +x /root/onekey_reality_ipv4.sh
}

install_temp_users_40ports() {
  echo "ğŸ§© å†™å…¥ /root/vless_temp_audit_ipv4_all.shï¼ˆå«é”é‡å…¥ä¿®å¤ï¼‰..."

  cat >/root/vless_temp_audit_ipv4_all.sh <<'EOF'
#!/usr/bin/env bash
set -euo pipefail

XRAY_BIN="/usr/local/bin/xray"
ENV_CONF="/usr/local/etc/xray/env.conf"

DIR="/usr/local/etc/xray/tmpusers"
LOG_USER="/var/log/vless-user.log"
LOG_GC="/var/log/vless-user-gc.log"
LOG_RS="/var/log/vless-user-restore.log"
LOCK="/var/lock/vless-tmpusers.lock"

mkdir -p "$DIR"
touch "$LOG_USER" "$LOG_GC" "$LOG_RS" 2>/dev/null || true
chmod 700 "$DIR" || true

# ---- helper: load env ----
cat >/usr/local/sbin/vless_load_env.sh <<'LEN'
#!/usr/bin/env bash
set -euo pipefail

ENV_CONF="/usr/local/etc/xray/env.conf"

REALITY_DOMAIN="${REALITY_DOMAIN:-www.apple.com}"
MAIN_PORT="${MAIN_PORT:-443}"
API_HOST="${API_HOST:-127.0.0.1}"
API_PORT="${API_PORT:-10085}"
TEMP_PORT_START="${TEMP_PORT_START:-40000}"
TEMP_PORT_COUNT="${TEMP_PORT_COUNT:-40}"

if [[ -f "$ENV_CONF" ]]; then
  # shellcheck disable=SC1090
  . "$ENV_CONF" || true
fi

[[ "${API_PORT}" =~ ^[0-9]+$ ]] || API_PORT=10085
[[ "${TEMP_PORT_START}" =~ ^[0-9]+$ ]] || TEMP_PORT_START=40000
[[ "${TEMP_PORT_COUNT}" =~ ^[0-9]+$ ]] || TEMP_PORT_COUNT=40
(( TEMP_PORT_COUNT > 0 )) || TEMP_PORT_COUNT=40

export REALITY_DOMAIN MAIN_PORT API_HOST API_PORT TEMP_PORT_START TEMP_PORT_COUNT
export API_SERVER="${API_HOST}:${API_PORT}"
LEN
chmod +x /usr/local/sbin/vless_load_env.sh

# ---- rmu (âœ…é”é‡å…¥ä¿®å¤ç‰ˆ) ----
cat >/usr/local/sbin/vless_rmu_one.sh <<'RMU'
#!/usr/bin/env bash
set -euo pipefail

EMAIL="${1:?need email}"
INBOUND_TAG="${2:?need inbound tag}"

XRAY_BIN="/usr/local/bin/xray"
DIR="/usr/local/etc/xray/tmpusers"
LOCK="/var/lock/vless-tmpusers.lock"

# ç»Ÿä¸€è¯»å– API_HOST/API_PORT
if [[ -x /usr/local/sbin/vless_load_env.sh ]]; then
  /usr/local/sbin/vless_load_env.sh
  API_SERVER="${API_SERVER:-127.0.0.1:10085}"
else
  API_SERVER="127.0.0.1:10085"
fi

# âœ… æ ¸å¿ƒä¿®å¤ï¼š
# å¦‚æœ fd 9 å·²ç»å­˜åœ¨ä¸”æŒ‡å‘åŒä¸€ä¸ª lock æ–‡ä»¶ï¼ˆé€šå¸¸æ¥è‡ªçˆ¶è¿›ç¨‹ vless_gc / vless_clear_all çš„ç»§æ‰¿ï¼‰ï¼Œ
# å°±ä¸è¦é‡æ–° exec 9>"$LOCK"ï¼›ç›´æ¥ flock -n 9ï¼ˆä¼šæˆåŠŸï¼Œä¸ä¼šè‡ªæˆ‘å†²çªï¼‰ã€‚
if [[ -e "/proc/$$/fd/9" ]]; then
  FD9_TARGET="$(readlink -f "/proc/$$/fd/9" 2>/dev/null || true)"
else
  FD9_TARGET=""
fi

if [[ "$FD9_TARGET" != "$LOCK" ]]; then
  exec 9>"$LOCK"
fi

flock -n 9 || { echo "âŒ busy"; exit 1; }

# API åˆ é™¤ï¼ˆå¤±è´¥ä¸è‡´å‘½ï¼šä»å°è¯•æ¸…ç†æœ¬åœ° meta/jsonï¼‰
"$XRAY_BIN" api rmu -s "$API_SERVER" -tag="$INBOUND_TAG" "$EMAIL" >/dev/null 2>&1 || true

# æ¸…ç†æœ¬åœ°æ–‡ä»¶
shopt -s nullglob
for m in "$DIR"/*.meta; do
  [[ -f "$m" ]] || continue
  if grep -q "EMAIL=$EMAIL" "$m"; then
    rm -f "$m" "${m%.meta}.json" 2>/dev/null || true
  fi
done
RMU
chmod +x /usr/local/sbin/vless_rmu_one.sh

# ---- mktemp ----
cat >/usr/local/sbin/vless_mktemp.sh <<'MK'
#!/usr/bin/env bash
set -euo pipefail
: "${D:?ç”¨æ³•: D=600 vless_mktemp.sh}"

XRAY_BIN="/usr/local/bin/xray"
DIR="/usr/local/etc/xray/tmpusers"
LOG="/var/log/vless-user.log"
LOCK="/var/lock/vless-tmpusers.lock"

# ç»Ÿä¸€è¯»å– API_HOST/API_PORT + ç«¯å£èŒƒå›´
/usr/local/sbin/vless_load_env.sh
API_SERVER="${API_SERVER}"

exec 9>"$LOCK"
flock -n 9 || { echo "âŒ å¦ä¸€ä¸ªå®ä¾‹æ­£åœ¨è¿è¡Œï¼Œè¯·ç¨åé‡è¯•"; exit 1; }

if ! "$XRAY_BIN" help api 2>/dev/null | grep -qE '\badu\b'; then
  echo "âŒ xray ä¸æ”¯æŒ api adu/rmu"; exit 1
fi
systemctl is-active --quiet xray.service || { echo "âŒ xray.service æœªè¿è¡Œ"; exit 1; }

if ! [[ "$D" =~ ^[0-9]+$ ]] || (( D <= 0 )); then
  echo "âŒ D å¿…é¡»æ˜¯æ­£æ•´æ•°ç§’"; exit 1
fi

# TTL å¤±è´¥å…œåº•ä¾èµ– timerï¼šæå‰æç¤º
if ! systemctl is-enabled --quiet vless-gc.timer 2>/dev/null; then
  echo "âš ï¸ vless-gc.timer æœªå¯ç”¨ï¼šè‹¥ TTL unit åˆ›å»ºå¤±è´¥ï¼Œè¿‡æœŸèŠ‚ç‚¹å¯èƒ½æ— æ³•è‡ªåŠ¨å›æ”¶ã€‚å»ºè®®ï¼šsystemctl enable --now vless-gc.timer" >&2
elif ! systemctl is-active --quiet vless-gc.timer 2>/dev/null; then
  echo "âš ï¸ vless-gc.timer æœªè¿è¡Œï¼šå»ºè®®ï¼šsystemctl start vless-gc.timer" >&2
fi

declare -A cnt
for ((i=0;i<TEMP_PORT_COUNT;i++)); do
  cnt[$((TEMP_PORT_START+i))]=0
done

while IFS= read -r p; do
  [[ "$p" =~ ^[0-9]+$ ]] || continue
  [[ -n "${cnt[$p]+x}" ]] && cnt[$p]=$((cnt[$p]+1))
done < <(awk -F= '/^PORT=/{print $2}' "$DIR"/*.meta 2>/dev/null || true)

# æœ€å°ä½¿ç”¨æ•° + éšæœºæ‰“æ•£
best_n=999999
for ((i=0;i<TEMP_PORT_COUNT;i++)); do
  p=$((TEMP_PORT_START+i))
  n=${cnt[$p]}
  if (( n < best_n )); then best_n=$n; fi
done

cands=()
for ((i=0;i<TEMP_PORT_COUNT;i++)); do
  p=$((TEMP_PORT_START+i))
  n=${cnt[$p]}
  if (( n == best_n )); then cands+=("$p"); fi
done

if command -v shuf >/dev/null 2>&1; then
  PORT="$(printf '%s\n' "${cands[@]}" | shuf -n1)"
else
  idx=$((RANDOM % ${#cands[@]}))
  PORT="${cands[$idx]}"
fi

INBOUND_TAG="vless-tmp-$PORT"

TAG="vless-temp-$(date +%Y%m%d%H%M%S)-$(openssl rand -hex 2)"
UUID="$("$XRAY_BIN" uuid)"
EMAIL="${TAG}@temp"
NOW=$(date +%s)
EXP=$((NOW + D))

CFG="$DIR/${TAG}.json"
META="$DIR/${TAG}.meta"

cat >"$CFG" <<JSON
{
  "inbounds": [
    {
      "tag": "${INBOUND_TAG}",
      "protocol": "vless",
      "settings": {
        "decryption": "none",
        "clients": [
          { "email": "${EMAIL}", "id": "${UUID}", "flow": "xtls-rprx-vision" }
        ]
      }
    }
  ]
}
JSON

TMPLOG="$(mktemp /tmp/adu.XXXXXX.log)"
chmod 600 "$TMPLOG" 2>/dev/null || true
trap 'rm -f "$TMPLOG" 2>/dev/null || true' EXIT

if ! "$XRAY_BIN" api adu -s "$API_SERVER" "$CFG" >"$TMPLOG" 2>&1; then
  cat "$TMPLOG" >&2
  echo "âŒ adu å¤±è´¥ï¼ˆAPI_SERVER=$API_SERVERï¼‰"
  exit 1
fi

cat >"$META" <<M
TAG=$TAG
EMAIL=$EMAIL
UUID=$UUID
PORT=$PORT
INBOUND_TAG=$INBOUND_TAG
EXPIRE_EPOCH=$EXP
M
chmod 600 "$META" "$CFG" 2>/dev/null || true

UNIT="vless-expire-$TAG"
if systemctl status "${UNIT}.service" >/dev/null 2>&1; then
  systemctl stop "${UNIT}.service" >/dev/null 2>&1 || true
  systemctl reset-failed "${UNIT}.service" >/dev/null 2>&1 || true
fi

if ! systemd-run --quiet --collect --unit "$UNIT" --on-active="${D}s" \
  /usr/local/sbin/vless_rmu_one.sh "$EMAIL" "$INBOUND_TAG"; then
  echo "âš ï¸ systemd-run åˆ›å»º TTL å¤±è´¥ï¼šå°†ä¾èµ– vless-gc.timer å…œåº•å›æ”¶ã€‚" >&2
  if systemctl enable --now vless-gc.timer >/dev/null 2>&1; then
    echo "âœ… å·²å°è¯•å¯ç”¨å¹¶å¯åŠ¨ vless-gc.timer" >&2
  else
    echo "âŒ æ— æ³•å¯ç”¨ vless-gc.timerï¼Œè¯·æ‰‹åŠ¨æ£€æŸ¥ systemd/timerï¼Œå¦åˆ™è¿‡æœŸèŠ‚ç‚¹å¯èƒ½ä¸å›æ”¶ã€‚" >&2
  fi
fi

MAIN="/root/vless_reality_vision_url.txt"
URL="(æœªæ‰¾åˆ° /root/vless_reality_vision_url.txtï¼Œè¯·ç”¨åŒå‚æ•°æ‹¼æ¥ï¼Œç«¯å£=$PORT UUID=$UUID)"
if [[ -f "$MAIN" ]]; then
  BASE="$(sed -n '1p' "$MAIN" || true)"
  if [[ -n "$BASE" ]]; then
    URL="$(echo "$BASE" \
      | sed -E "s#^vless://[^@]+@#vless://${UUID}@#; s#@([^:/]+):[0-9]+\?#@\1:${PORT}?#; s/#.*/#${TAG}/")"
  fi
fi

E_STR=$(TZ=Asia/Shanghai date -d "@$EXP" '+%F %T')
echo "$(date '+%F %T %Z') create $TAG port=$PORT email=$EMAIL exp=$EXP" >> "$LOG" 2>/dev/null || true

echo "âœ… æ–°ä¸´æ—¶èŠ‚ç‚¹(å•è¿›ç¨‹): $TAG"
echo "ç«¯å£: $PORT ï¼ˆinbound: $INBOUND_TAGï¼‰"
echo "UUID: $UUID"
echo "åˆ°æœŸ(åŒ—äº¬æ—¶é—´): $E_STR"
echo "é“¾æ¥:"
echo "$URL"
MK
chmod +x /usr/local/sbin/vless_mktemp.sh

# ---- gc (çˆ¶è„šæœ¬æŒé” + è°ƒ rmu å­è„šæœ¬ï¼›ç°åœ¨ä¸ä¼šé”å†²çª) ----
cat >/usr/local/sbin/vless_gc.sh <<'GC'
#!/usr/bin/env bash
set -euo pipefail
shopt -s nullglob

DIR="/usr/local/etc/xray/tmpusers"
LOG="/var/log/vless-user-gc.log"
LOCK="/var/lock/vless-tmpusers.lock"

exec 9>"$LOCK"
flock -n 9 || exit 0

touch "$LOG" 2>/dev/null || true
NOW=$(date +%s)

for META in "$DIR"/*.meta; do
  unset TAG EMAIL EXPIRE_EPOCH INBOUND_TAG
  . "$META" 2>/dev/null || continue
  [[ -z "${EMAIL:-}" || -z "${EXPIRE_EPOCH:-}" || -z "${INBOUND_TAG:-}" ]] && continue
  [[ ! "${EXPIRE_EPOCH}" =~ ^[0-9]+$ ]] && continue
  if (( EXPIRE_EPOCH <= NOW )); then
    /usr/local/sbin/vless_rmu_one.sh "$EMAIL" "$INBOUND_TAG" || true
    echo "$(date '+%F %T %Z') [gc] removed $EMAIL tag=$INBOUND_TAG" >> "$LOG" 2>/dev/null || true
  fi
done
GC
chmod +x /usr/local/sbin/vless_gc.sh

# ---- restore ----
cat >/usr/local/sbin/vless_restore.sh <<'RS'
#!/usr/bin/env bash
set -euo pipefail
shopt -s nullglob

XRAY_BIN="/usr/local/bin/xray"
DIR="/usr/local/etc/xray/tmpusers"
LOG="/var/log/vless-user-restore.log"
LOCK="/var/lock/vless-tmpusers.lock"

/usr/local/sbin/vless_load_env.sh
API_SERVER="${API_SERVER}"

exec 9>"$LOCK"
flock -n 9 || exit 0

touch "$LOG" 2>/dev/null || true
NOW=$(date +%s)

for META in "$DIR"/*.meta; do
  unset EXPIRE_EPOCH INBOUND_TAG EMAIL TAG
  . "$META" 2>/dev/null || continue
  [[ -z "${EXPIRE_EPOCH:-}" || -z "${INBOUND_TAG:-}" || -z "${EMAIL:-}" || -z "${TAG:-}" ]] && continue
  [[ ! "${EXPIRE_EPOCH}" =~ ^[0-9]+$ ]] && continue
  CFG="${META%.meta}.json"

  if (( EXPIRE_EPOCH > NOW )); then
    if [[ -f "$CFG" ]]; then
      "$XRAY_BIN" api adu -s "$API_SERVER" "$CFG" >/dev/null 2>&1 || true
      REM=$((EXPIRE_EPOCH - NOW))

      UNIT="vless-expire-$TAG"
      if systemctl status "${UNIT}.service" >/dev/null 2>&1; then
        systemctl stop "${UNIT}.service" >/dev/null 2>&1 || true
        systemctl reset-failed "${UNIT}.service" >/dev/null 2>&1 || true
      fi

      if ! systemd-run --quiet --collect --unit "$UNIT" --on-active="${REM}s" \
        /usr/local/sbin/vless_rmu_one.sh "$EMAIL" "$INBOUND_TAG"; then
        echo "âš ï¸ [restore] systemd-run TTL å¤±è´¥ï¼šå°†ä¾èµ– vless-gc.timer å…œåº•ã€‚" >&2
        systemctl enable --now vless-gc.timer >/dev/null 2>&1 || true
      fi

      echo "$(date '+%F %T %Z') [restore] $TAG rem=${REM}s" >> "$LOG" 2>/dev/null || true
    fi
  else
    rm -f "$META" "$CFG" 2>/dev/null || true
  fi
done
RS
chmod +x /usr/local/sbin/vless_restore.sh

# ---- audit / clear_all (çˆ¶è„šæœ¬æŒé” + è°ƒ rmu å­è„šæœ¬ï¼›ç°åœ¨ä¸ä¼šé”å†²çª) ----
cat >/usr/local/sbin/vless_audit.sh <<'AUD'
#!/usr/bin/env bash
set -euo pipefail
shopt -s nullglob

DIR="/usr/local/etc/xray/tmpusers"
echo "==== XRAY ä¸»è¿›ç¨‹ ===="
echo "xray.service: $(systemctl is-active xray.service 2>/dev/null || echo unknown)"
echo

printf "%-42s %-6s %-6s %-20s %-14s %-20s\n" "TAG" "PORT" "STATE" "EMAIL" "LEFT" "EXPIRE(China)"
NOW=$(date +%s)

for META in "$DIR"/*.meta; do
  unset TAG EMAIL PORT EXPIRE_EPOCH
  . "$META" 2>/dev/null || continue
  [[ -z "${TAG:-}" || -z "${EMAIL:-}" || -z "${PORT:-}" || -z "${EXPIRE_EPOCH:-}" ]] && continue
  [[ ! "${EXPIRE_EPOCH}" =~ ^[0-9]+$ ]] && continue

  LEFT=$((EXPIRE_EPOCH - NOW))
  if (( LEFT <= 0 )); then
    STATE="expired"
    LEFT_STR="expired"
  else
    STATE="alive"
    D=$((LEFT/86400)); H=$(((LEFT%86400)/3600)); M=$(((LEFT%3600)/60))
    LEFT_STR=$(printf "%02dd%02dh%02dm" "$D" "$H" "$M")
  fi
  EXPIRE_AT_FMT="$(TZ='Asia/Shanghai' date -d "@${EXPIRE_EPOCH}" '+%Y-%m-%d %H:%M:%S')"
  printf "%-42s %-6s %-6s %-20s %-14s %-20s\n" "$TAG" "$PORT" "$STATE" "$EMAIL" "$LEFT_STR" "$EXPIRE_AT_FMT"
done
AUD
chmod +x /usr/local/sbin/vless_audit.sh

cat >/usr/local/sbin/vless_clear_all.sh <<'CLR'
#!/usr/bin/env bash
set -euo pipefail
shopt -s nullglob

DIR="/usr/local/etc/xray/tmpusers"
LOCK="/var/lock/vless-tmpusers.lock"

exec 9>"$LOCK"
flock -n 9 || { echo "âŒ busy"; exit 1; }

echo "== æ¸…ç©ºæ‰€æœ‰ä¸´æ—¶èŠ‚ç‚¹ =="
for META in "$DIR"/*.meta; do
  unset EMAIL INBOUND_TAG
  . "$META" 2>/dev/null || continue
  [[ -z "${EMAIL:-}" || -z "${INBOUND_TAG:-}" ]] && continue
  /usr/local/sbin/vless_rmu_one.sh "$EMAIL" "$INBOUND_TAG" || true
done
echo "âœ… done"
CLR
chmod +x /usr/local/sbin/vless_clear_all.sh

# ---- systemd units ----
cat >/etc/systemd/system/vless-restore.service <<'SVC'
[Unit]
Description=Restore temp VLESS users (single xray, multi-port)
After=network.target xray.service
Wants=xray.service

[Service]
Type=oneshot
ExecStart=/usr/local/sbin/vless_restore.sh
Nice=19
IOSchedulingClass=idle

[Install]
WantedBy=multi-user.target
SVC

cat >/etc/systemd/system/vless-gc.service <<'SVC'
[Unit]
Description=GC temp VLESS users (single xray, multi-port)
After=network.target xray.service
Wants=xray.service

[Service]
Type=oneshot
ExecStart=/usr/local/sbin/vless_gc.sh
Nice=19
IOSchedulingClass=idle
SVC

cat >/etc/systemd/system/vless-gc.timer <<'TMR'
[Unit]
Description=Run VLESS GC every 10 minutes

[Timer]
OnBootSec=2min
OnUnitActiveSec=10min
Persistent=true

[Install]
WantedBy=timers.target
TMR

systemctl daemon-reload
systemctl enable --now vless-gc.timer >/dev/null 2>&1 || true
systemctl enable vless-restore.service >/dev/null 2>&1 || true
systemctl start vless-restore.service >/dev/null 2>&1 || true

echo "âœ… å•è¿›ç¨‹ + å¤šç«¯å£ ä¸´æ—¶èŠ‚ç‚¹ç³»ç»Ÿéƒ¨ç½²å®Œæˆï¼ˆå«é”é‡å…¥ä¿®å¤ï¼‰"
echo "ç”¨æ³•ï¼šD=600 vless_mktemp.sh / vless_audit.sh / vless_clear_all.sh"
EOF

  chmod +x /root/vless_temp_audit_ipv4_all.sh
}

install_port_quota_hard_10min() {
  echo "ğŸ§© éƒ¨ç½² TCP ä¸Šè¡Œé…é¢ç³»ç»Ÿï¼ˆç¡¬é…é¢ï¼šè¶…é‡ç«‹å³ dropï¼›10 åˆ†é’Ÿä¿å­˜å¿«ç…§ï¼›ä¿å­˜å¸¦ flush rulesetï¼‰..."
  apt-get install -y nftables >/dev/null || true
  mkdir -p /etc/portquota

  nft list table inet portquota >/dev/null 2>&1 || nft add table inet portquota
  nft list chain inet portquota down_out >/dev/null 2>&1 || nft add chain inet portquota down_out '{ type filter hook output priority filter; policy accept; }'

  systemctl enable --now nftables >/dev/null 2>&1 || true

  cat >/usr/local/sbin/pq_save.sh <<'SAVE'
#!/usr/bin/env bash
set -euo pipefail
TMP="/etc/nftables.conf.tmp"
DST="/etc/nftables.conf"
LOG="/var/log/pq-save.log"
touch "$LOG" 2>/dev/null || true

{
  echo "flush ruleset"
  nft list ruleset
} > "$TMP" || {
  echo "$(date '+%F %T %Z') [pq-save] å¯¼å‡ºå¤±è´¥" >> "$LOG"
  rm -f "$TMP" 2>/dev/null || true
  exit 1
}

mv "$TMP" "$DST"
echo "$(date '+%F %T %Z') [pq-save] saved" >> "$LOG"
SAVE
  chmod +x /usr/local/sbin/pq_save.sh

  cat >/usr/local/sbin/pq_add.sh <<'ADD'
#!/usr/bin/env bash
set -euo pipefail
PORT="${1:-}"; GIB="${2:-}"
[[ -n "$PORT" && -n "$GIB" ]] || { echo "ç”¨æ³•: pq_add.sh <ç«¯å£> <GiBæ•´æ•°>"; exit 1; }

[[ "$PORT" =~ ^[0-9]+$ ]] || { echo "âŒ ç«¯å£å¿…é¡»æ˜¯æ•°å­—"; exit 1; }
(( PORT >= 1 && PORT <= 65535 )) || { echo "âŒ ç«¯å£èŒƒå›´å¿…é¡» 1-65535"; exit 1; }

[[ "$GIB" =~ ^[0-9]+$ ]] || { echo "âŒ GiBéœ€æ•´æ•°"; exit 1; }
BYTES=$((GIB * 1024 * 1024 * 1024))

nft -a list chain inet portquota down_out 2>/dev/null | awk -v p="$PORT" '$0 ~ "tcp sport "p" " {print $NF}' \
  | while read -r h; do nft delete rule inet portquota down_out handle "$h" 2>/dev/null || true; done

nft delete counter inet portquota "pq_allow_$PORT" 2>/dev/null || true
nft delete counter inet portquota "pq_drop_$PORT"  2>/dev/null || true
nft add counter inet portquota "pq_allow_$PORT"
nft add counter inet portquota "pq_drop_$PORT"

nft add rule inet portquota down_out tcp sport "$PORT" \
  quota over "$BYTES" bytes counter name "pq_drop_$PORT" drop comment "pq-drop-$PORT"

nft add rule inet portquota down_out tcp sport "$PORT" \
  counter name "pq_allow_$PORT" accept comment "pq-allow-$PORT"

cat >/etc/portquota/pq-"$PORT".meta <<M
PORT=$PORT
LIMIT_BYTES=$BYTES
LIMIT_GIB=$GIB
MODE=quota_hard
ALLOW_COUNTER=pq_allow_$PORT
DROP_COUNTER=pq_drop_$PORT
M

/usr/local/sbin/pq_save.sh >/dev/null 2>&1 || true
echo "âœ… ç«¯å£ $PORT ç¡¬é…é¢ ${GIB}GiBï¼ˆè¶…é‡ç«‹å³ dropï¼‰"
ADD
  chmod +x /usr/local/sbin/pq_add.sh

  cat >/usr/local/sbin/pq_del.sh <<'DEL'
#!/usr/bin/env bash
set -euo pipefail
PORT="${1:-}"
[[ -n "$PORT" ]] || { echo "ç”¨æ³•: pq_del.sh <ç«¯å£>"; exit 1; }

[[ "$PORT" =~ ^[0-9]+$ ]] || { echo "âŒ ç«¯å£å¿…é¡»æ˜¯æ•°å­—"; exit 1; }
(( PORT >= 1 && PORT <= 65535 )) || { echo "âŒ ç«¯å£èŒƒå›´å¿…é¡» 1-65535"; exit 1; }

nft -a list chain inet portquota down_out 2>/dev/null | awk -v p="$PORT" '$0 ~ "tcp sport "p" " {print $NF}' \
  | while read -r h; do nft delete rule inet portquota down_out handle "$h" 2>/dev/null || true; done

nft delete counter inet portquota "pq_allow_$PORT" 2>/dev/null || true
nft delete counter inet portquota "pq_drop_$PORT"  2>/dev/null || true
rm -f /etc/portquota/pq-"$PORT".meta

/usr/local/sbin/pq_save.sh >/dev/null 2>&1 || true
echo "âœ… åˆ é™¤ç«¯å£ $PORT é…é¢"
DEL
  chmod +x /usr/local/sbin/pq_del.sh

  cat >/usr/local/sbin/pq_audit.sh <<'AUDIT'
#!/usr/bin/env bash
set -euo pipefail
shopt -s nullglob

get_bytes() {
  local c="$1"
  nft list counter inet portquota "$c" 2>/dev/null \
    | awk '/bytes/{for(i=1;i<=NF;i++) if($i=="bytes"){print $(i+1); exit}}' \
    | head -n1 \
    || true
}

printf "%-8s %-10s %-12s %-12s %-8s %-12s %-12s\n" "PORT" "STATE" "USED(GiB)" "LIMIT(GiB)" "PERCENT" "ALLOW(GiB)" "DROP(GiB)"

for META in /etc/portquota/pq-*.meta; do
  unset PORT LIMIT_BYTES MODE ALLOW_COUNTER DROP_COUNTER
  . "$META" 2>/dev/null || continue
  [[ -z "${PORT:-}" || -z "${LIMIT_BYTES:-}" || -z "${MODE:-}" ]] && continue
  ALLOW_COUNTER="${ALLOW_COUNTER:-pq_allow_${PORT}}"
  DROP_COUNTER="${DROP_COUNTER:-pq_drop_${PORT}}"

  A="$(get_bytes "$ALLOW_COUNTER")"; [[ -z "$A" ]] && A=0
  D="$(get_bytes "$DROP_COUNTER")";  [[ -z "$D" ]] && D=0
  CUR=$((A + D))

  USED="$(awk -v b="$CUR" 'BEGIN{printf "%.2f",b/1024/1024/1024}')"
  LIM="$(awk -v b="$LIMIT_BYTES" 'BEGIN{printf "%.2f",b/1024/1024/1024}')"
  AL="$(awk -v b="$A" 'BEGIN{printf "%.2f",b/1024/1024/1024}')"
  DR="$(awk -v b="$D" 'BEGIN{printf "%.2f",b/1024/1024/1024}')"
  PCT="$(awk -v u="$CUR" -v l="$LIMIT_BYTES" 'BEGIN{if(l>0) printf "%.1f%%",(u*100.0)/l; else print "N/A"}')"

  STATE="ok"
  if (( D > 0 )); then
    STATE="dropped"
  elif (( A >= LIMIT_BYTES )); then
    STATE="limit"
  fi

  printf "%-8s %-10s %-12s %-12s %-8s %-12s %-12s\n" "$PORT" "$STATE" "$USED" "$LIM" "$PCT" "$AL" "$DR"
done
AUDIT
  chmod +x /usr/local/sbin/pq_audit.sh

  cat >/etc/systemd/system/pq-save.service <<'PQSVC'
[Unit]
Description=Save nftables ruleset

[Service]
Type=oneshot
ExecStart=/usr/local/sbin/pq_save.sh
Nice=19
IOSchedulingClass=idle
PQSVC

  cat >/etc/systemd/system/pq-save.timer <<'PQTMR'
[Unit]
Description=Periodically save nftables ruleset

[Timer]
OnBootSec=2min
OnUnitActiveSec=600s
Persistent=true

[Install]
WantedBy=timers.target
PQTMR

  systemctl daemon-reload >/dev/null 2>&1 || true
  systemctl enable --now pq-save.timer >/dev/null 2>&1 || true
  /usr/local/sbin/pq_save.sh >/dev/null 2>&1 || true
}

main() {
  check_debian12
  need_basic_tools
  download_upstreams

  install_logrotate_rules
  install_update_all
  install_vless_script_singleproc_40ports
  install_temp_users_40ports
  install_port_quota_hard_10min

  cat <<DONE

==================================================
âœ… å·²ç”Ÿæˆå…¨éƒ¨è„šæœ¬ï¼ˆå«é”é‡å…¥ä¿®å¤ï¼šGC/clear_all ä¸å†å‡åˆ é™¤ï¼‰
- /root/onekey_reality_ipv4.sh
- /root/vless_temp_audit_ipv4_all.sh

å»ºè®®é¡ºåºï¼š
1) update-all && reboot
2) bash /root/onekey_reality_ipv4.sh     ï¼ˆå†™ /usr/local/etc/xray/env.confï¼‰
3) bash /root/vless_temp_audit_ipv4_all.sh

å¸¸ç”¨å‘½ä»¤ï¼š
- åˆ›å»ºä¸´æ—¶èŠ‚ç‚¹ï¼š
  D=600 vless_mktemp.sh

- å®¡è®¡ä¸´æ—¶èŠ‚ç‚¹ï¼š
  vless_audit.sh

- æ¸…ç©ºæ‰€æœ‰ä¸´æ—¶èŠ‚ç‚¹ï¼š
  vless_clear_all.sh

é…é¢ï¼š
- pq_add.sh 40000 50
- pq_audit.sh
- pq_del.sh 40000
==================================================
DONE
}

main "$@"
